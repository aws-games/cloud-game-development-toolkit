---
- name: Install and Configure Perforce
  hosts: all
  become: yes
  collections:
    - amazon.aws
  vars:
    log_file: "/var/log/p4_setup.log"
    sdp_root: "/hxdepots/sdp/helix_binaries"
    sdp: "/hxdepots/sdp"
    package: "policycoreutils-python-utils"
    required_binaries:
      - p4
      - p4broker
      - p4d
      - p4p
    default_helix_version: "r23.1"
    default_bin_list: "p4,p4d,p4p,p4broker"
    perforce_ftp_base_url: "https://ftp.perforce.com/perforce"
    stage_bin_dir: "/hxdepots/sdp/helix_binaries"
    download_apis: false
    flag_file: "/var/run/p4_configure_ran.flag"
    p4d_type: "{{ p4d_type | default('p4d_master') }}"
    p4d_admin_username_secret_id: "{{ p4d_admin_username_secret_id }}"
    p4d_admin_pass_secret_id: "{{ p4d_admin_pass_secret_id }}"
    helix_auth_service_url: "{{ helix_auth_service_url | default('') }}"
    fqdn: "{{ fqdn | default('') }}"
    ebs_logs: "{{ ebs_logs }}"
    ebs_metadata: "{{ ebs_metadata }}"
    ebs_depots: "{{ ebs_depots }}"
    case_sensitive: "{{ case_sensitive | default('1') }}"
    unicode: "{{ unicode | default('false') }}"
    topology_file: "/etc/perforce/topology.json"

  pre_tasks:
    - name: Ensure pip is installed
      package:
        name: python3-pip
        state: present
      become: yes

    - name: Install required Python libraries
      pip:
        name:
          - boto3
          - botocore

  tasks:
    - name: Example task
      debug:
        msg: "Project Prefix: {{ PROJECT_PREFIX }}, Environment: {{ ENVIRONMENT }}"

    - name: Check if playbook has already run
      stat:
        path: "{{ flag_file }}"
      register: flag_file_stat

    - name: Exit if playbook has already run
      meta: end_play
      when: flag_file_stat.stat.exists

    - name: Ensure running as root
      fail:
        msg: "This playbook must be run as root"
      when: ansible_user_id != "root"

    - name: Ensure required directories exist
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "/etc/perforce"
        - "/var/log/perforce"

    - name: Get IMDSv2 token
      shell: |
        TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
        echo $TOKEN
      register: imdsv2_token

    - name: Get AWS Region
      shell: |
        curl -H "X-aws-ec2-metadata-token: {{ imdsv2_token.stdout }}" http://169.254.169.254/latest/meta-data/placement/region
      register: aws_region

    - name: Debug AWS region
      debug:
        msg: "AWS Region: {{ aws_region.stdout }}"
    
    - name: Set SSM parameter name
      set_fact:
        ssm_param_name: "/{{ PROJECT_PREFIX }}/{{ ENVIRONMENT }}/perforce/topology"

    - name: Debug SSM parameter name
      debug:
        msg: "SSM Parameter Name: {{ ssm_param_name }}"

    - name: Fetch topology from AWS Parameter Store
      set_fact:
        ssm_topology: "{{ lookup('amazon.aws.ssm_parameter', ssm_param_name, region=aws_region.stdout) }}"        

    - name: Parse fetched topology
      set_fact:
        new_topology: "{{ ssm_topology }}"

    - name: Check if local topology file was previously written
      stat:
        path: "{{ topology_file }}"
      register: topology_stat

    - name: Read existing topology if it exists
      block:
        - name: Read existing topology
          slurp:
            src: "{{ topology_file }}"
          register: existing_topology_raw

        - name: Parse existing topology
          set_fact:
            existing_topology: "{{ existing_topology_raw['content'] | b64decode | from_json }}"
      when: topology_stat.stat.exists

    - name: Compare topologies and update if necessary
      block:
        - name: Check if topology has changed
          set_fact:
            topology_changed: "{{ new_topology.version != existing_topology.version }}"

        - name: Log topology change
          lineinfile:
            path: "{{ log_file }}"
            line: "{{ ansible_date_time.iso8601 }} - Topology change detected. New version: {{ new_topology.version }}"
            create: yes
          when: topology_changed

        - name: Update local topology file
          copy:
            content: "{{ new_topology | to_nice_json }}"
            dest: "{{ topology_file }}"
          when: topology_changed
      when: topology_stat.stat.exists
      
    - name: Store new topology if it doesn't exist locally
      copy:
        content: "{{ new_topology | to_nice_json }}"
        dest: "{{ topology_file }}"
      when: not topology_stat.stat.exists

    - name: Fetch instance metadata
      ec2_metadata_facts:
      no_log: true

    - name: Check if ServerType tag exists
      set_fact:
        server_type_tag_exists: "{{ 'ServerType' in ansible_ec2_instance_tags_keys }}"

    - name: Debug ServerType tag existence
      debug:
        var: server_type_tag_exists

    - name: Set facts based on instance metadata
      set_fact:
        server_type: "{{ 'ServerType' in ansible_ec2_instance_tags_keys }}"

    - name: Set server-specific facts
      set_fact:
        commit_server_dns: "{{ new_topology.servers.commit.private_dns }}"
        replica_server_dns: "{{ new_topology.servers.replica.private_dns | default('') }}"
        edge_server_dns: "{{ new_topology.servers.edge.private_dns | default('') }}"

    - name: Display server information
      debug:
        msg: 
          - "Server Type: {{ server_type }}"
          - "Commit Server DNS: {{ commit_server_dns }}"
          - "Replica Server DNS: {{ replica_server_dns }}"
          - "Edge Server DNS: {{ edge_server_dns }}"

    - name: Ensure perforce group exists
      group:
        name: perforce
        state: present

    - name: Ensure perforce user exists
      user:
        name: perforce
        group: perforce
        home: /home/perforce
        shell: /bin/bash
        create_home: yes

    - name: Set up sudoers for perforce user
      copy:
        content: "perforce ALL=(ALL) NOPASSWD:ALL"
        dest: /etc/sudoers.d/perforce
        mode: '0400'

    - name: Create required directories
      file:
        path: "{{ item }}"
        state: directory
        owner: perforce
        group: perforce
        mode: '0755'
      loop:
        - /hxdepots
        - /hxlogs
        - /hxmetadata

    - name: Download SDP
      get_url:
        url: https://swarm.workshop.perforce.com/download/guest/perforce_software/sdp/downloads/sdp.Unix.tgz
        dest: /hxdepots/sdp.Unix.tgz

    - name: Extract SDP
      unarchive:
        src: /hxdepots/sdp.Unix.tgz
        dest: /hxdepots
        remote_src: yes

    - name: Set permissions for SDP
      file:
        path: "{{ sdp }}"
        state: directory
        recurse: yes
        mode: 'u+w'

    - name: Check for required binaries
      stat:
        path: "{{ sdp_root }}/{{ item }}"
      register: binary_stats
      loop: "{{ required_binaries }}"

    - name: Ensure the target directory exists
      file:
        path: "{{ stage_bin_dir }}"
        state: directory
        mode: '0755'

    - name: Set Helix version
      set_fact:
        helix_version: "{{ helix_version | default(default_helix_version) }}"

    - name: Set binary list
      set_fact:
        bin_list: "{{ bin_list | default(default_bin_list) }}"

    - name: Determine OS and architecture
      set_fact:
        os_name: "{{ ansible_system | lower }}"
        os_arch: "{{ ansible_architecture }}"

    - name: Set platform for each binary
      set_fact:
        platform: >-
          {%- if os_name == 'linux' -%}
          linux26{{ 'x86_64' if os_arch == 'x86_64' else '' }}
          {%- else -%}
          {{ os_name }}{{ '64' if os_arch == 'x86_64' else '' }}
          {%- endif -%}

    - name: Download binaries
      get_url:
        url: "{{ perforce_ftp_base_url }}/{{ helix_version }}/bin.{{ platform | trim }}/{{ item }}"
        dest: "{{ stage_bin_dir }}/{{ item }}"
        mode: '0755'
      loop: "{{ bin_list.split(',') }}"
      register: download_result
      retries: 3
      delay: 5
      until: download_result is success

    - name: Get binary versions
      command: "{{ stage_bin_dir }}/{{ item }} -V"
      register: version_info
      changed_when: false
      loop: "{{ bin_list.split(',') }}"

    - name: Display binary versions
      debug:
        msg: "Version of {{ item.item }}: {{ item.stdout_lines[0] }}"
      loop: "{{ version_info.results }}"

    - name: Download APIs
      block:
        - name: Get API directory listing
          uri:
            url: "{{ perforce_ftp_base_url }}/{{ helix_version }}/bin.{{ platform }}/"
            return_content: yes
          register: api_dir_content

        - name: Extract API filenames
          set_fact:
            api_files: "{{ api_dir_content.content | regex_findall('href=\"(p4api-.*?.tgz)\"') }}"

        - name: Download API files
          get_url:
            url: "{{ perforce_ftp_base_url }}/{{ helix_version }}/bin.{{ platform }}/{{ item }}"
            dest: "{{ stage_bin_dir }}/{{ item }}"
          loop: "{{ api_files }}"

        - name: Display API versions
          command: tar -tzf {{ stage_bin_dir }}/{{ item }} | head -1
          register: api_versions
          changed_when: false
          loop: "{{ api_files }}"

        - name: Show API versions
          debug:
            msg: "Version of {{ item.item }}: {{ item.stdout.split('/')[0] }}"
          loop: "{{ api_versions.results }}"
      when: download_apis | bool

    - name: Set ownership of SDP_Root
      file:
        path: "{{ sdp_root }}"
        state: directory
        recurse: yes
        owner: perforce
        group: perforce

    - name: Resolve AWS secrets
      amazon.aws.aws_secret:
        name: "{{ item.secret_id }}"
        region: "{{ aws_region }}"
      register: aws_secrets
      loop:
        - { secret_id: "{{ p4d_admin_username_secret_id }}", var_name: "p4d_admin_username" }
        - { secret_id: "{{ p4d_admin_pass_secret_id }}", var_name: "p4d_admin_pass" }
      no_log: true

    - name: Set secret values as facts
      set_fact:
        "{{ item.item.var_name }}": "{{ item.secret }}"
      loop: "{{ aws_secrets.results }}"
      no_log: true


    - name: Prepare EBS volumes or mount FSx
      block:
        - name: Create temporary mount points
          file:
            path: "{{ item }}"
            state: directory
          loop:
            - /mnt/temp_hxlogs
            - /mnt/temp_hxmetadata
            - /mnt/temp_hxdepots

    - name: Get device information
      set_fact:
        device_info:
          - path: "/mnt/temp_hxlogs"
            src: "{{ ebs_logs }}"
          - path: "/mnt/temp_hxmetadata"
            src: "{{ ebs_metadata }}"
          - path: "/mnt/temp_hxdepots"
            src: "{{ ebs_depots }}"

    - name: Identify device types and prepare for mounting
      set_fact:
        mount_info: "{{ mount_info | default([]) + [{ 
          'path': item.path, 
          'src': item.src,
          'is_nfs': item.src is regex('fs-[0-9a-f]{17}\\.fsx\\.[a-z0-9-]+\\.amazonaws\\.com:/'),
          'fstype': 'nfs' if (item.src is regex('fs-[0-9a-f]{17}\\.fsx\\.[a-z0-9-]+\\.amazonaws\\.com:/')) else 'xfs',
          'opts': 'nconnect=16,rsize=1048576,wsize=1048576,timeo=600' if (item.src is regex('fs-[0-9a-f]{17}\\.fsx\\.[a-z0-9-]+\\.amazonaws\\.com:/')) else 'defaults'
        }] }}"
      loop: "{{ device_info }}"

    - name: Debug mount info
      debug:
        var: mount_info

    - name: Ensure mount directories exist
      file:
        path: "{{ item.path }}"
        state: directory
        mode: '0755'
      loop: "{{ mount_info }}"

    - name: Get actual device names for EBS volumes
      shell: |
        lsblk -nlo NAME,SERIAL | grep "{{ item.src | regex_replace('/dev/', '') }}" | awk '{print $1}'
      register: actual_device_names
      when: not item.is_nfs
      loop: "{{ mount_info }}"

    - name: Update mount info with actual device names
      set_fact:
        mount_info: "{{ mount_info | map('combine', {'actual_src': item.stdout if item.stdout else item.item.src}) | list }}"
      loop: "{{ actual_device_names.results }}"
      when: not item.skipped | default(false)

    - name: Check if EBS filesystems are formatted
      command: "blkid {{ item.actual_src }}"
      register: blkid_results
      failed_when: false
      changed_when: false
      when: not item.is_nfs
      loop: "{{ mount_info }}"

    - name: Format EBS filesystems if needed
      filesystem:
        fstype: xfs
        dev: "{{ item.item.actual_src }}"
      when: not item.item.is_nfs and item.rc != 0
      loop: "{{ blkid_results.results }}"

    - name: Mount volumes or FSx
      mount:
        path: "{{ item.path }}"
        src: "{{ item.actual_src | default(item.src) }}"
        fstype: "{{ item.fstype }}"
        opts: "{{ item.opts }}"
        state: mounted
      loop: "{{ mount_info }}"

    - name: Sync directories
      synchronize:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
      loop:
        - { src: "/hxlogs/", dest: "/mnt/temp_hxlogs/" }
        - { src: "/hxmetadata/", dest: "/mnt/temp_hxmetadata/" }
        - { src: "/hxdepots/", dest: "/mnt/temp_hxdepots/" }

    - name: Unmount temporary mounts
      mount:
        path: "{{ item }}"
        state: unmounted
      loop:
        - /mnt/temp_hxlogs
        - /mnt/temp_hxmetadata
        - /mnt/temp_hxdepots

    - name: Clear destination directories
      file:
        path: "{{ item }}/*"
        state: absent
      loop:
        - /hxlogs
        - /hxmetadata
        - /hxdepots

    - name: Mount EBS volumes or FSx to final destinations
      mount:
        path: "{{ item.path }}"
        src: "{{ item.src }}"
        fstype: "{{ 'nfs' if item.src | regex_search('fs-[0-9a-f]{17}\\.fsx\\.[a-z0-9-]+\\.amazonaws\\.com:/') else 'xfs' }}"
        opts: "{{ 'nconnect=16,rsize=1048576,wsize=1048576,timeo=600' if item.src | regex_search('fs-[0-9a-f]{17}\\.fsx\\.[a-z0-9-]+\\.amazonaws\\.com:/') else 'defaults' }}"
        state: mounted
      loop:
        - { path: "/hxlogs", src: "{{ ebs_logs }}" }
        - { path: "/hxmetadata", src: "{{ ebs_metadata }}" }
        - { path: "/hxdepots", src: "{{ ebs_depots }}" }

    - name: Update mkdirs.cfg
      lineinfile:
        path: /hxdepots/sdp/Server/Unix/setup/mkdirs.cfg
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      loop:
        - { regexp: '^P4ADMINPASS=', line: 'P4ADMINPASS={{ p4d_admin_pass }}' }
        - { regexp: '^ADMINUSER=', line: 'ADMINUSER={{ p4d_admin_username }}' }
        - { regexp: '^P4MASTERHOST=', line: 'P4MASTERHOST={{ ansible_hostname }}' }
        - { regexp: '^CASE_SENSITIVE=', line: 'CASE_SENSITIVE=CASE_SENSITIVE' }

    - name: Execute mkdirs.sh
      command: /hxdepots/sdp/Server/Unix/setup/mkdirs.sh 1 -t {{ p4d_type }}
      args:
        chdir: /hxdepots/sdp/Server/Unix/setup

    - name: Update SSL config with EC2 DNS name
      lineinfile:
        path: /p4/ssl/config.txt
        regexp: '^REPL_DNSNAME'
        line: "{{ fqdn | default(ansible_ec2_public_hostname) }}"

    - name: Generate SSL certificate
      command: /p4/common/bin/p4master_run 1 /p4/1/bin/p4d_1 -Gc

    - name: Configure systemd service
      template:
        src: "{{ sdp }}/Server/Unix/p4/common/etc/systemd/system/p4d_N.service.t"
        dest: /etc/systemd/system/p4d_1.service
        owner: root
        group: root
        mode: '0644'

    - name: Reload systemd
      systemd:
        daemon_reload: yes

    - name: Start p4d service
      systemd:
        name: p4d_1
        state: started

    - name: Wait for p4d service to start
      wait_for:
        port: 1666
        timeout: 300

    - name: Create symlink for p4 binary
      file:
        src: "{{ sdp_root }}/p4"
        dest: /usr/bin/p4
        state: link

    - name: Trust p4 server
      command: p4 -p ssl:{{ ansible_hostname }}:1666 trust -y

    - name: Execute configure_new_server.sh
      command: /p4/sdp/Server/setup/configure_new_server.sh 1

    - name: Execute live_checkpoint.sh
      command: /p4/sdp/Server/Unix/p4/common/bin/live_checkpoint.sh 1
      become: yes
      become_user: perforce

    - name: Execute recreate_offline_db.sh
      command: /p4/sdp/Server/Unix/p4/common/bin/recreate_offline_db.sh 1
      become: yes
      become_user: perforce

    - name: Fix crontab
      lineinfile:
        path: /p4/p4.crontab.1
        regexp: '\*/60'
        line: '0'

    - name: Initialize crontab for perforce user
      cron:
        name: "Perforce cron jobs"
        user: perforce
        cron_file: /p4/p4.crontab.1

    - name: Verify SDP installation
      command: /hxdepots/p4/common/bin/verify_sdp.sh 1


    - name: Create SiteTags file
      template:
        src: /hxdepots/sdp/Server/Unix/p4/common/config/SiteTags.cfg.sample
        dest: /hxdepots/p4/common/config/SiteTags.cfg

    - name: Append AWS region to SiteTags
      lineinfile:
        path: /hxdepots/p4/common/config/SiteTags.cfg
        line: "aws{{ aws_region.stdout | replace('-', '') }}"